---
title: "전체적인 개념 정리"
tags: 개념정리
date: "2023.04.10"
categories: 
    - Til
---

## 객체지향
- 모든 데이터를 객체로 취급하여 처리하는 프로그래밍 방법. 객체 자신이 독립적으로 동작하고 다른 객체의 부품으로도 사용된다.

<br>

## 추상화
- 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업을 의미한다. 일반적으로 추상화는 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위이다. 자바에서 추상화란 공통된 행위나 필드를 모아서 클래스를 만드는 것이다.

<br>

## MVC 패턴
- Model,View,Controller의 약자로 애플리케이션을 세 가지 역할로 구분한 방법론이다. 사용자가 Controller를 조작하면 Controller는 Model을 통해 데이터를 가져오고 그 데이터를 바탕으로 View를 통해 시각적 표현을 제어하여 사용자에게 전달하게 된다.

<br>

## 데이터베이스 옵티마이저
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다. 사용자가 구조회된 SQL로 결과 집합을 요구하면 이를 생성하는데 필요한 처리경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해준다. 옵티마이저가 생성한 SQL 처리경로를 Exrcution Plan이라고 한다.

<br>

## 풀스캔(FULL SCAN)
- 수직적 탐색 없이 인덱스 블록을 처음부터 끝까지 수평적으로 탐생하는 방식. 최적의 인덱스가 없을 때 차선으로 선택

<br>

## 코드 리팩토링
- 결과의 변경 없이 코드의 구조를 재 조정함을 뜻함
    - 주로 가독성을 높이고 유지보수를 편하게 함
    - 버그를 없애거나 새로운 기능을 추가하는 행위는 아님
    - 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 개선하는 유지보수 행위

<br>

## Java Collection
- Collection 객체는 여러 원소들을 담을 수 있는 자료구조를 뜻한다. 배열이 가장 기본적인 자료구조이다.
    - 순서가 있는 목록인 List
    - 순서가 중요하지 않은 목록인 Set
    - 먼저 들어온 것이 먼저 나가는 Queue
    - Key,VALUE 형태로 저장되는 Map 등

<br>

## 가비지 컬렉션 알고리즘
- 

<br>

## 배열 안 중복 제거 방법
- Array를 Set으로 변환 후 다시 Array로 변환
    - Set은 중복을 허용하지 않기 때문에 중복이 있는 Array를 Set으로 변환 시 중복이 제거됨
    ```java
            // 배열을 HashSet으로 변환 (중복이 제거됨)
        HashSet<String> hashSet = new HashSet<>(Arrays.asList(arr));
        // HashSet을 배열로 변환 (중복(Dup)이 제거된 배열)
        arr = hashSet.toArray(new String[0]);
    ```
    - LinkedSet은 순서가 보장되는 Set이다.
    ```java
            // 배열을 HashSet으로 변환 (중복이 제거됨)
        LinkedHashSet<String> linkedhashSet = new LinkedHashSet<>(Arrays.asList(arr));
        // HashSet을 배열로 변환 (중복(Dup)이 제거된 배열)
        arr = linkedhashSet.toArray(new String[0]);
    ```
- Stream distinct()를 활용하여 중복 제거(JAVA8)
    - Array를 Stream으로 변환 후 distinct()를 활용하여 중복 제거 후 다시 Array로 변환
    ```java
            // 배열 -> Stream -> distinct (중복제거) -> 배열
        arr = Arrays.stream(arr).distinct().toArray(String[]::new);
    ```
- 임시 Array를 이용하여 중복제거
    - 임시 배열을 사용하여 중복제거. 배열상 옆 데이터를 바로 비교하기 때문에 Sort. 때문에 순서보장 X
    ```java
        // 배열 sorting
        //Arrays.sort(arr);
        
        // 임시 배열 선언
        String[] tempArr = new String[n]; 

        // 중복 제거 후 array의 길이
        int j = 0;  

        // 임시 배열 구성
        for (int i=0; i<n-1; i++){  
            if (arr[i] != arr[i+1]){  
                tempArr[j++] = arr[i];  
            }
        }
        tempArr[j++] = arr[n-1];       

        // 중복 제거된 배열 구성
        arr = new String[j];
        for (int i=0; i<j; i++){  
            arr[i] = tempArr[i];  
        }
    ```
- 중복데이터를 치환 후 제거하여 중복 제거
    - 중복데이터를 변환 후 분기처리하여 중복제거
    ```java
            // 중복 제거 후 array의 길이
        int k = 0;  

        // 중복되는 데이터 "" 변환
        for (int i=0; i<n-1; i++){  
            for (int j=i+1;j<n;j++) {
                if (!arr[i].equals("") && arr[i].equals(arr[j])) {
                    arr[j] = "";
                    k++;
                }
            }
        }

        String[] resultArr = new String[n-k];
        int tmpindex = 0;

        //새로운 배열 생성
        for (String str : arr) {
            if (!"".equals(str)) {
                resultArr[tmpindex] = str;
                tmpindex++;
            }
        }
    ```

<br>

## Spring DI (Dependency Injection)
- 스프링이 다른 프레임워크와 차별화 되어 제공하는 의존 관계 주입 기능으로 객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식. 이로인해 모듈 간의 결합도가 낮아지고 유연성이 높아진다.

<br>

## JPA 장점
- 생산성
    - CRUD 쿼리를 작성해줘야 하던 MyBatis와 같은 Mapper 방식은 컬럼이 추가되거나 하면 수정해줘야 하는 부분이 상당히 많았다. JPA를 사용하게 되면 쿼리를 직접 생성하는 것이 아니라 만들어진 객체로 데이터베이스를 다루기 때문에 객체 중심으로 개발을 진행할 수 있다.
- 유지보수
    - 단순히 엔티티 클래스 정보만 변경하면 쉽게 관리가 가능함
- 성능
    - 일반적인 Spring encache 기능처럼 동일한 쿼리에 대한 캐시 기능을 사용하기 때문에 더욱 높은 성능적 효율성을 경험할 수 있음

<br>

## JPA 단점
- 복잡한 쿼리보단 실시간 처리용 쿼리에 더 최적화 되어 있음. Native query기능을 사용할 수 있지만 복잡하고 미세하게 쿼리작업이 필요하다면 Mybatis와 같은 Mapper 방식을 사용하는 것이 더 효율적임.

<br>

## JWT란? 장점과 단점은?
- JWT는 Json Web Token의 약자로 일반적으로 클라이언트와 서버 사이에서 통신할 때 권한을 위해 사용하는 토큰. 웹 상에서 정보를 Json형태로 주고 받기 위해 표준 규약에 따라 생성한 암호화된 토큰으로 복잡하고 읽을 수 없는 string 형태로 저장되어 있다.
- 장점
    - 필요한 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없음
    - URL파라미터와 헤더로 사용
    - 쿠키를 전달하지 않아도 됨. 취약점 감소
- 단점
    - 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있음
    - 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 함

<br>

## MSA란 무엇인가 ? 장점과 단점은?
- 느슨하게 결합된 서비스의 모임으로 구조화하는 서비스지향 아키텍처 스타일의 일종인 소프트웨어 개발 기법
- 장점
    - 배포
        - 서비스별 개별 배포가 가능함. 빠르게 배포 가능
    - 확장
        - 클라우드 기반 서비스 사용에 적합
    - 장애
        - 일부 장애가 전체 서비스로 확장될 가능성이 적음
    - 그 외
        - 새로운 기술을 적용하기 유연함(특정 서비스만 별도의 기술 또는 언어로 구현가능)
- 단점
    - 설계가 어려움
    - 데이터 관리
        - 데이터가 여러 서비스에 분산되어 있어 조회가 어려움
        - 데이터를 관리하기 어려움

<br>

## java reflection 이란
- 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

<br>

## java의 장점과 단점
- 장점
    - 기존 코드를 재사용하고 모듈식 프로그램을 개발할 수 있다.
    - 플랫폼에 구애받지 않는다.
    - 보안에 강하다.
- 단점
    - 실행속도가 C, C++에 비해 느리다.
    - 이해하기 힘든 긴 코드가 많기 때문에 코드를 읽고 이해하는 데 어려움을 겪을 수 있다.

<br>

## 세션과 쿠키의 차이
- 쿠키
    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
    - 사용자 인증이 유효한 시간을 명시할 수 있고 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지됨
    - 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음. 하나의 쿠키값은 4KB까지 저장한다.
    쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request싱 Request Header를 넣어서 자동으로 서버에 전송함
- 세션
    - 쿠키를 기반하고 있지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버측에서 관리함
    - 쿠키보다 보안에 좋지만 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨
    - 동접자 수가 많은 경우 서버에 과부하를 주게 됨. 성능저하의 원인
- 차이
    - 비슷한 역할을 하며 동작 원리도 비슷함. 그 이유는 세션도 결국 쿠키를 사용하기 때문
    - 가장 큰 차이점은 사용자 정보가 저장되는 위치. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않고 세션은 서버의 자원을 사용함
    - 보안 면에서 세션이 우수함. 요청속도는 쿠키가 세션보다 빠름. 세션은 서버의 처리가 필요하기 때문

<br>


